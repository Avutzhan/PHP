Главная цель этих принципов — повысить гибкость вашей
архитектуры, уменьшить связанность между её компонента-
ми и облегчить повторное использование кода.

Здесь это в основном выражается в услож-
нении кода программы. В реальной жизни, пожалуй, нет
такого кода, в котором бы соблюдались все эти принципы
сразу.

Single responsibility

У класса должен быть только один мотив для
изменения.

если в классе есть разнородное поведение
лишнее поведение переносим в отдельный класс

Open Closed

Расширяйте классы, но не изменяйте их первоначаль-
ный код.

Стремитесь к тому, чтобы классы были открыты для рас-
ширения, но закрыты для изменения.

например нужно написать класс так чтобы потом не приходилось менять его
то есть лишние методы перенести в свои собственные классы и при добавлении новых возможностей просто
создавать новые классы а сам класс основной не трогать

бонус метода в том что можно применять принцип едиственной ответственности и лишние методы переносить
в свои собственные классы

Liskov Substitution

Подклассы должны дополнять, а не замещать поведе-
ние базового класса.

Стремитесь создавать подклассы таким образом, чтобы их
объекты можно было бы подставлять вместо объектов базо-
вого класса, не ломая при этом функциональности клиент-
ского кода

пример с котом

метод умеет кормить кота если дать ему не кота то все сломается
создаем более абстрактный интерфейс животные и имплементим на кота
добавляем это в метод чтобы он кормил любых животных и все ок

возвращаемый тип должен совпадать или быть подтипом
если метод возвращает кота или бенгальского кота все отработает норм
если метод вернет животное оно асбтрактное им может быть даже крокодил
в итоге возможна ошибка

плохо когда базовый метод возвращает строку а переопределенный метод число

типы исключений должны совпадать или быть подтипами другие могут уронить всю программу

В большинстве современных языков программирова-
ния, особенно строго типизированных (Java, C# и дру-
гие), перечисленные ограничения встроены прямо в
компилятор. Поэтому вы попросту не сможете собрать
программу, нарушив их

метод не должен ужесточать условия если работал до этого со всеми цифрами
и вы ограничили отрицательные числа то программа упадет

нельзя ослаблять условия если базовый код отключал все подключения
а переопределенный не отключал то клиентский код может закрыть подключения
и оставить запущенные процессы призраки

Инварианты класса должны остаться без изменений. Инва-
риант — это набор условий, при которых объект имеет
смысл. Например, инвариант кота — это наличие четырёх
лап, хвоста, способность мурчать и прочее

Подкласс не должен изменять значения приватных полей
базового класса. Этот пункт звучит странно, но в некоторых
языках доступ к приватным полям можно получить через
механизм рефлексии. В некоторых других языках (Python,
JavaScript) и вовсе нет жёсткой защиты приватных полей

Interface Segregation

Клиенты не должны зависеть от методов, которые они
не используют.

Стремитесь к тому, чтобы интерфейсы были достаточно узки-
ми, чтобы классам не приходилось реализовывать избыточ-
ное поведение.


Принцип разделения интерфейсов говорит о том, что слиш-
ком «толстые» интерфейсы необходимо разделять на более
маленькие и специфические, чтобы клиенты маленьких
интерфейсов знали только о методах, которые необходи-
мы им в работе. В итоге при изменении метода интерфей-
са не должны меняться клиенты, которые этот метод не
используют.

Dependency Inversion

Классы верхних уровней не должны зависеть от клас-
сов нижних уровней. Оба должны зависеть от абстрак-
ций. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

Принцип инверсии зависимостей часто идёт в ногу с прин-
ципом открытости/закрытости: вы сможете расширять низ-
коуровневые классы и использовать их вместе с классами
бизнес-логики, не изменяя код последних.

пример класс budgetReport высокий уровень а класс сохранения
данных в базе низкий уровень. Высокоуровневый класс зависит от низкоуровневого

исправим пиешм интерфейс database это уже абстракция и создаем разные классы сохранения
данных и теперь они зависят от абстракции
то есть низкоуровневые классы теперь зависят от высокоуровневых














