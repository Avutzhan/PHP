**********************Рекурсия*************************

Пример с чемоданом

Допустим, вы разбираете чулан своей бабушки и натыкаетесь на загадочный
запертый чемодан.
Бабушка говорит, что ключ к чемодану, скорее всего, лежит в коробке .
В коробке лежат другие коробки, а в них лежат маленькие коробочки. Ключ
находится где-то там. Какой алгоритм поиска ключа предложите вы? По­
думайте над алгоритмом, прежде чем продолжить чтение.

1 Сложить все коробки в кучу
2 Взять коробку и открыть
3 Если внутри лежит коробка добавить ее в кучу для последующего поиска
4 Если внутри лежит ключ поиск закончен
5 Повторить

можно посторить на цикле
Какое решение кажется вам более простым? Первое решение можно постро­
ить на цикле while. Пока куча коробок не пуста, взять очередную коробку
и проверить ее содержимое :

есть второй способ

1 Посмотерть содержимое коробки
2 Если вы найдете коробку вернуться к шагу 1
3 Если вы найдете ключ поиск завершен

а это решение делается на рекурсии
Рекурсией называется вызов функцией
самой себя.

Оба решения делают одно и то же, но второе решение кажется мне более
понятным и локаничным певрвое какое то трудное и длинное

Рекурсия применяется тогда, когда решение становится более
понятным. Применение рекурсии не ускоряет работу программы: более
того, решение с циклами иногда работает быстрее. Мне нравится одна ци­
тата Ли Колдуэлла с сайта Stack Overlow: циклы могут ускорить работу
программы . Рекурсия может ускорить работу программиста. Выбирайте,
что важнее в вашей ситуации!

Рекурсия используется во многих нужных алгоритмах, поэтому важно по­
нимать эту концепцию .

Базовый случай и рекурсивный случай

так как функция вызывает саму себя можно легко написать функцию которая вызывается бесконечно
нужно писать в какой момент следует прервать функцию
вот почему каждая рекурсивная функция состоит из двух частей базового и рекурсивного случая
в рекурсивном случае функция вызывает сама себя
в базовом случае функция себя не вызывает чтобы предотвратить зацикливание

пример бесконечного кода
def countdown(i):
print i
countdow n(i-1)

пример с базовым случаем
def countdown(i):
print i
if i <= 0       //если i меньше или равно 0 то работа закончена
    return
else            //если i больше 0 значит опять вызываем себя только минус 1
    countdow n(i-1)

********************Стек****************************

Стек - простая структура данных.
stack first in last out
ставка в начало вывод из конца

Во внутренней работе вашего компьютера используется стек, называемый
стеком вызовов.

def greet(name):
    print "hello, " + name + "!"
    greet(name)
    print "getting ready to say bye..."
    bye()

def greet2(name):
    print "how are you, " + name + "?"
def bye():
    print "ok bye"!

что происходит при вызове функции greet('maggie')
Сначала ваш компьютер выделяет блок памяти для этого вызова функции.
___________________
|                  |
|                  |
|__________________|

пустой блок памяти

Затем эта память используется. Переменной name присваивается значение
"maggie"; оно должно быть сохранено в памяти.

записываем в этот блок данные
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Каждый раз , когда вы вызываете функцию , компьютер сохраняет в памяти
значения всех переменных для этого вызова.

Далее выводится приветствие hello, maggie ! , после чего
следует второй вызов greet2( "maggie" ). И снова
компьютер выделяет блок памяти для вызова функции.

___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Ваш компьютер объединяет эти блоки в стек. Второй блок создается над первым.

Вы выводите сообщение how are you, maggie?, после чего воз­
вращаете управление из вызова функции. Когда это происходит, блок на
вершине стека извлекается из него .

___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции который уже отработал и мы его удаляем
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Теперь верхний блок в стеке относится к функции greet; это означает, что
вы вернулись к функции greet.

При вызове функции greet2 функция greet еще не была завершена.

Здесь-то и скрывается истинный смысл этого раздела: когда вы вызываете
функцию из другой функции, вызывающая функция приостанавливается в частично завершеноом состоянии.
Все значения переменных этой функции остаются в памяти.
А когда выполнение функции greet2 будет завершено, вы вернетесь к функции greet и продолжите ее
выполнение с того места, где оно прервалось.

Сначала выводится сообщение getting ready to say Ьуе ... , после чего вызывается функция Ьуе.
___________________
|       BYE        |
|                  |    <----- текущий вызов функции
|__________________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Блок для этой функции добавляется на вершину стека. Далее выводится
сообщение ok Ьуе ! с выходом из вызова функции.

___________________
|       BYE        |
|                  |    <----- текущий вызов функции уже отработал и мы его удаляем
|__________________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Управление снова возвращается функции greet. Делать больше нечего, так
что управление возвращается и из функции greet. Этот стек, в котором со­
хранялись переменные разных функций, называется стеком вызовов.

упражнение

что можно сказать об этом стеке
___________________
|    greet2        |
--------------------
| name:  | maggie  |    <----- текущий вызов функции
|________|_________|
___________________
|    greet         |
--------------------
| name:  | maggie  |
|________|_________|

Ответ: Некоторые наблюдения , о которых вы могли бы упомянуть:

1 сначала вызывается функция greet для переменной name = maggie
2 затем функция greet вызывает функцию greet2 для переменной name = maggie
3 на этой стадии функция greet находится в незавершенном, приостановленном состоянии;
4 текущим вызовом функции является вызов greet2
5 после завершения этого вызова функция greet продолжит выполнение.

А теперь посмотрим , как работает стек вызовов с рекурсивными функ­
циями.

