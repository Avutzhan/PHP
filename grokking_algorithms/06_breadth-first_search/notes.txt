Вы научитесь моделировать сети при помощи новой абстрактной структуры данных  графов

Вы освоите поиск в ширину  алгоритм, который применяется к графам для получения ответов на вопросы
вида «Какой кратчайший путь ведет к Х?»

Вы узнаете, чем направленные графы отличаются от
ненаправленных.

Вы освоите топологическую сортировку другой алго­
ритм сортировки, раскрывающий связи между узлами.

Эта глава посвящена графам. Сначала вы узнаете, что такое граф. Затем
я покажу первый алгоритм, работающий с графами. Он называется поиском
в ширину (BFS, Breadth-First Search).

Поиск в ширину позволяет найти кратчайшее расстояние между двумя объ­
ектами. Однако сам термин «кратчайшее расстояние» может иметь много
разных значений! Например, с помощью поиска в ширину можно:

написать программу для игры в шашки, которая вычисляет кратчайший
путь к победе;

реализовать проверку правописания (минимальное количество измене­
ний, преобразующих ошибочно написанное слово в правильное, напри­
мер АЛГОРИФМ ->АЛГОРИТМ одно изменение);

найти ближайшего к вам врача.

Одни из самых полезных алгоритмов, известных мне, работают с графами.

Знакомство с графами

Предположим, вы находитесь в Сан-Франциско и хотите добраться из
Твин-Пике к мосту Золотые Ворота. Вы намереваетесь доехать на автобусе
с минимальным количеством пересадок. Возможные варианты:

Графы похожи на таблици связей между обьектами в UML BPMN вформате

Какой алгоритм вы бы использовали для поиска пути с наименьшим коли­
чеством шагов?

Можно ли сделать это за один шаг? На следующем рисунке выделены все
места, в которые можно добраться за один шаг.

Мост на этой схеме не выделен; до него невозможно добраться за один шаг.
А можно ли добраться до него за два шага?

И снова мост не выделен, а значит, до него невозможно добраться за два
шага. Как насчет трех шагов?

Ага! На этот раз мост Золотые Ворота выделен. Следовательно, чтобы до­
браться из Твин-Пике к мосту по этому маршруту, необходимо сделать три
шага.

Есть и другие маршруты, которые приведут вас к мосту, но они длиннее
(четыре шага). Алгоритм обнаружил, что кратчайший путь к мосту состоит
из трех шагов. Задача такого типа называется задачей поиска кратчайшего
пути. Часто требуется найти некий кратчайший путь: путь к дому вашего
друга, путь к победе в шахматной партии (за наименьшее количество ходов)
и т. д . Алгоритм для решения задачи поиска кратчайшего пути называется
поиском в ширину .

Чтобы найти кратчайший путь из Твин-Пике к мосту Золотые Ворота, нам
пришлось выполнить два шага:

1 Смоделировать задачу в виде графа.
2 Решить задачу методом поиска в ширину.

В следующем раздел е я расскажу, что такое графы. Затем будет рассмотрен
более подробно поиск в ширину.

Что такое граф?

Граф моделирует набор связей. Пред­
ставьте, что вы с друзьями играете в по­
кер и хотите смоделировать, кто кому
сейчас должен. Например, условие
«Алекс должен Раме» можно смодели­
ровать так:

алекс -> рама

Алекс должен Раме, Том должен Адиту и т. д. Каждый граф состоит из узлов
и ребер.

стр 132 рисунок

Бот и все! Графы состоят из узлов и ребер. Узел может быть напрямую со­
единен с несколькими другими узлами. Эти узлы называются соседями. На
этом графе Рама является соседом Алекса. С другой стороны, Адит соседом
Алекса не является, потому что они не соединены напрямую . При этом Адит
является соседом Рамы и Тома.

Графы используются для моделирования связей между разными объектами .
А теперь посмотрим, как работает поиск в ширину.

В главе 1 уже рассматривался пример алгоритма поиска: бинарный по­
иск. Поиск в ширину также относится к категории алгоритмов поиска,
но этот алгоритм работает с графами. Он помогает ответить на вопросы
двух типов:
тип 1: существует ли путь от узла А к узлу В?
тип 2: как выглядит кратчайший путь от узла А к узлу В?

Бы уже видели пример поиска в ширину, когда мы просчитывали кратчай­
ший путь из Твин-Пике к мосту Золотые Ворота. Это был вопрос типа
2: как выглядит кратчайший путь? Теперь разберем работу алгоритма более
подробно с вопросом типа 1: существует ли путь?

Представьте, что вы выращиваете манго. Бы ищете продавца, который
будет продавать ваши замечательные манго. А может, продавец найдется
среди ваших контактов на Facebook?
Для начала стоит поискать среди друзей.

у вас есть три друга алиса клэр и боб

Поиск происходит вполне тривиально.
Сначала нужно построить список друзей для поиска.
Теперь нужно обратиться к каждому человеку в списке
и проверить, продает ли этот человек манго.
Предположим , ни один из ваших друзей не продает манго. Теперь поиск
продолжается среди друзей ваших друзей .

картинка стр 134

Каждый раз, когда вы проверяете кого-то из списка, вы добавляете в список
всех его друзей.

В таком случае поиск ведется не только среди друзей, но и среди друзей
друзей тоже.

Напомним: нужно найти в сети хотя бы одного продавца ман­
го. Если Алиса не продает манго, то в список добавляются ее друзья . Это
означает, что со временем вы проверите всех ее друзей, а потом их друзей
и т. д . С эти м алгоритмом поиск рано или поздно пройдет по всей сети , пока
вы все-таки не наткнетесь на продавца манго. Тако й алгоритм и называется
поиском в ширину.

Поиск кратчайшего пути

На всякий случай напомню два вопроса, на которые может ответить алго­
ритм поиска в ширину:

тип 1: существует ли путь от узла А к узлу В? (Есть ли продавец манго
в вашей сети?)
тип 2: как выглядит кратчайший путь от узла А к узлу В? (Кто из про­
давцов манго находится ближе всего к вам?)

Вы уже знаете, как ответить на вопрос вопрос 1;.
теперь попробуем ответить на 2
Удастся ли вам найти ближайшего продавца манго? Будем счи ­
тать, что ваши друзья это связи первого уровня, а друзья друзей связи второго уровня.

Связи первого уровня предпочтительнее связей второго уровня, свя зи
второго уровня предпочтительнее связей третьего уровня и т. д. Отсюда
следует, что поиск по контактам второго уровня не долже н производить­
ся, пока вы не будете полностью уверены в том, что среди связей первого
уровня нет ни одного продавца манго. Но ведь поиск в ширину именно это
и делает! Поиск в ширину распространяется от начальной точки. А это оз­
начает, что связи первого уровня будут проверены до связей второго уровня.
Контрольный вопрос: кто будет проверен первым , Клэр или Анудж? Ответ:

Клэр является связью первого уровня, а Анудж - связью второго уровня.
Следовательно, Клэр будет проверена первой.

Также можно объяснить это иначе: связи первого уровня добавляются
в список поиска раньше связей второго уровня.

Вы двигаетесь вниз по списку и проверяете каждого
человека (является ли он продавцом манго). Связи
первого уровня будут проверены до связей второго
уровня, так что вы найдете продавца манго, ближай­
шего к вам. Поиск в ширину находит не только путь
из А в В, но и кратчайший путь.

Обратите внимание: это условие выполняется только
в том случае, если поиск осуществляется в порядке
добавления людей. Другими словами, если Клэр была
добавлена в список до Ануджа, то проверка Клэр должна быть выполнена
до проверки Ануджа. А что произойдет, если вы проверите Ануджа раньше,
чем Клэр, и оба они окажутся продавцами манго? Анудж является связью
второго уровня, а Клэр - связью первого уровня. В результате будет найден
продавец манго, не ближайший к вам в сети. Следовательно, проверять свя­
зи нужно в порядке их добавления. Для операций такого рода существует
специальная структура данных, которая называется очередью.

Очереди структуры данных

Очередь работает точно так же, как
и в реальной жизни. Предполо­
жим, вы с другом стоите в очереди
на автобусной остановке. Если вы
стоите ближе к началу очереди, то
вы первым сядете в ;штобус. Струк­
тура данных очереди работает ана­
логично. Очереди чем-то похожи
на стеки: вы не можете обращаться
к произвольным элементам очере­
ди . Вместо этого поддерживаются
всего две операции: постановка
в очередь и извлечение из очереди.

Если вы поставите в очередь два элемента, то элемент, добавленный пер­
вым, будет извлечен из очереди раньше второго. А ведь это свойство можно
использовать для реализации списка поиска! Люди , добавленные в список
первыми, будут извлечены из очереди и проверены первыми .

Очередь относится к категории структур данных
FIFO: First In, First Out
(«первым вошел, первым вышел»).
А стек принадлежит к числу структур данных
LIFO: Last In, First Out
(«последним пришел , первым вышел»).

Теперь, когда вы знаете, как работает очередь, можно переходить к реали­
зации поиска в ширину!

Очередь как реальная очередь первым вошел первым вышел
1, 2, 3, 4
А стек как стопка листов друг на друге последний пришел но так как последний листок стоит на верху его и первым извлекут

Упражнения









