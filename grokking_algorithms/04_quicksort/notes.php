Узнаем о стратегии разделяй и властвуй

Мы исследуем принцип ~разделяй и властвуй>,>, хорошо известный рекурсивный метод
решения задач.

Этот алгоритм сортировки работает на­
много быстрее сортировки выбором

Пример стратегии разделяй и властвуй
Представьте, что вы фермер, владеющий земельным участком.

Вы хотите равномерно разделить землю на одинаковые квадратные участ­
ки. Участки должны быть настолько большими, насколько это возможно,
так что ни одно из следующих решений не подойдет.

не квадратное, слишком маленькие, все участки должны быть одинаковыми

Как определить наибольший размер квадрата для участка? Воспользуйтесь
стратегией «разделяй и властвуй~! Алгоритмы на базе этой стратегии яв­
ляются рекурсивными.

Решение задачи методом «разделяй и властвуй ~ состоит из двух шагов:

1 Сначала определяется базовый случай. Это должен быть простейший
случай из всех возможных.
2 Задача делится или сокращается до тех пор, пока не будет сведена к ба­
зовому случаю .

А теперь воспользуемся стратегией «разделяй и властвуй~ для поиска ре­
шения этой задачи. Каков самый большой размер квадрата, который может
использоваться?

Для начала нужно определить базовый случай. Самая простая ситуация
-
если длина одной стороны кратна длине другой стороны .

Предположим , длина одной стороны составляет 25 м,
а длина другой 50 м В этом случае размер самого большого участка составляет 25 м х 25 м
и надел после деления будет состоять из двух участков

Теперь нужно вычислить рекурсивный случай. Здесь-то вам на помощь
и приходит стратегия «разделяй и властвуй ~ .

В соответствии с ней при каждом рекурсивном вызове задача должна сокращаться. Как сократить
эту задачу? Для начала разметим самые большие участки, которые можно использовать.

В исходном наделе можно разместить два участка 640 х 640,  и еще останется место. Тут-то и наступает момент истины .
Нераспределенный остаток - это тоже надел земли, который нужно разделить. Так почему бы не применить
к нему тот же алгоритм?

Итак, мы начали с надела 1680 х 640, который необходимо разделить на
участки. Но теперь разделить нужно меньший сегмент 640 х 400

Если вы найдете самый большой участок, подходящий для этого размера, это
будет самый большой участок, подходящий для всей фермы. Мы только
что сократили задачу с размера 1680 х 640 х до 640 х 400

Алгоритм Евклида если вы найдете самый болшой участок подходящий для этого размера
это будет самый большой участок подходящий для всей фермы

Применим тот же алгоритм снова. Если начать
с участка 640 х 400 то размеры самого большого квадрата
который можно создать, составляют 400 х 400

Остается меньший сегмент с размерами 400 х 240

Отсекая поделенную часть, мы приходим к еще меньшему размеру сегмента, 240 х 160

После очередного отсечения получается еще меньший сегмент.

Эге, да мы пришли к базовому случаю: 160 кратно 80

Если разбить этот
сегмент на квадраты, ничего лишнего не останется! 80 х 80

Итак, для исходного надела земли самый большой размер участка будет
равен 80 х 80

Вспомните, как работает стратегия ~разделяй и властвуй•:

1 Определите простейший случай как базовый.

2 Придумайте, как свести задачу к базовому случаю.

«Разделяй и властвуй~ не простой алгоритм, который можно применить
для решения задачи. Скорее, это подход к решению задачи. Рассмотрим
еще один пример.

Нужно просуммировать все числа и вернуть сумму. Сделать это в цикле
совсем не сложно:

второй пример

def sum(arr)
    total = 0
    fro x in arr:
        total += x
    return total

print sum([1, 2, 3, 4])

Но как сделать то же самое с использованием рекурсивной функции?

Шаг 1
определить базовый случай. Как выглядит самый простой массив,
который вы можете получить? Подумайте, как должен выглядеть про­
стейший случай, и продолжайте читать. Если у вас будет массив с О или
1 элементом, он суммируется достаточно просто.

[ ] базовый случай 0 элементов = сумма равна 0
[7] 1 элемент = сумма равна 7

Итак, с базовым случаем мы определились.

Шаг 2
каждый рекурсивный
вызов должен приближать вас к пустому мас­
сиву. Как уменьшить размер задачи? Один из возможных способов:

sum([2, 4, 6]) = 12

2 + sum([4, 6]) = 2 + 10 = 12

В любом случае результат равен 12  Но во второй версии функции sum
передается меньший массив. А это означает, что вы сократил и размер своей
задачи!

Функция sum может работать
по следующей схеме:

получить список

если пусть вернуть 0

в противном случае результат равен сумме первого числа в списке и суммы остального списка

А вот как это выглядит в действии.

sum ([2, 4, 6]) 12
2 + sum([4, 6]) 2 +10 = 12
4 + sum([6]) 4 + 6 = 10
базовый случай
sum([6]) = 6

Когда вы пишете рекурсивную функцию, в которой задействован массив, ба­
зовым случаем часто оказывается пустой массив или массив из одного эле­
мента. Если вы не знаете, с чего начать, - начните с этого.

Зачем применять рекурсию, если задача легко решается с циклом?
Вполне резонный вопрос. Что ж, пора познакомиться с функцио­
нальным программированием!

В языках функционального программирования, таких как Haskell ,
циклов нет, поэтому для написания подобных функций приходит­
ся применять рекурсию.

sum [] = 0 базовый
sum (x:xs) = x + (sum xs) рекурсивный случай

На первый взгляд кажется, что одна функция имеет два определе­
ния. Первое определение выполняется для базового случая, а вто­
рое  - для рекурсивного случая .

Функцию также
Haskell с использованием команды if
sum arr = if arr == []
            then 0
            else (head arr) + (sum (tail arr))

Но первое определение проще читается. Так как рекурсия широко
применяется в языке haskell
в него включены всевозможные удоб­
ства для ее использования. Если вам нравится рекурсия или вы хо­
тите изучить новый язык присмотритесь к haskell

упражнения

Напишите код для функции sum

def sum(list):
    if list == [] :
        return 0
    return list[0] + sum(list[1:])


Напишите рекурсивную функцию для подсчета элементов в списке.

def count(list):
    if list == [] :
        return 0
    return 1 + count(list[1:])

Найдите наибольшее число в списке.

def max(list):
    if len(list) == 2:
        return list[0] if list[0] > list[1] else list[1]
    sub_max = max(list[1:])
    return list[0) if list[0] > sub_max else sub_max

Помните бинарный поиск из главы 1? Он тоже относится к классу ал­
горитмов ~разделяй и властвуй~. Сможете ли вы определить базовый
и рекурсивный случай для бинарного поиска?


Ответ: Базовым случаем для бинарного поиска является массив,
содержащий всего один элемент. Если искомый элемент совпадает
с элементом массива  вы нашли его
В противном случае элемент
в массиве отсутствует.

В рекурсивном случае для бинарного поиска массив делится пополам,
одна половина отбрасывается, а для другой половины проводится
бинарный поиск.


Воспользуемся быстрой сортировкой для упорядо­
чения массива. Как выглядит самый простой массив,
с которым может справиться алгоритм сортировки
(помните подсказку из предыдущего раздела)? Не­
которые массивы вообще не нуждаются в сорти­
ровке.

самый простой массив это пустой или с одним элементом
такие массивы не нужно сортировать

Пустые массивы и массивы, содержащие всего один элемент, станут базо­
вым случаем. Такие массивы можно просто возвращать в исходном виде
- сортировать ничего не нужно:

def quick sor t(array):
    if len(array) < 2:
        return array

Теперь перейдем к массивам большего размера. Массив из двух элементов
тоже сортируется без особых проблем.

[1, 7] сравниваем два элемента если первый элемент меньше второго меняем их местами

А как насчет массива из трех элементов?

Помните: мы используем стратегию «разделяй и властвуй» . Следователь­
но, массив должен разделяться до тех пор, пока мы не придем к базовому
случаю. Алгоритм быстрой сортировки работает так: сначала в массиве
выбирается элемент, который называется опорным.

О том, как выбрать хороший опорный элемент, будет рассказано далее.
А пока предположим, что опорным становится первый элемент массива.

Теперь мы находим элементы, меньшие опорного, и элементы, большие
опорного.

например опорный элемент 33
в массиве

15 10 меньще 33 числа больше нет значит пустой массив

Этот процесс называется разделением. Теперь у вас имеются :

1 подмассив всех элементов, меньших опорного;

2 опорный элемент;

3 подмассив всех элементов, больших опорного.

Два подмассива не отсортированы они просто выделены из исходного
массива. Но если бы они бъuiu отсортированы, то провести сортировку всего
массива было бы несложно.

10 15 33 []

Если бы подмассивы были отсортированы, то их можно было бы объеди­
нить в порядке ~левый подмассив опорный элемент правый подмассив» и получить отсортированный массив .

В нашем примере получается
[ 10, 15] + [ 33] + [] = [ 10, 15, 33],
то есть отсортированный массив.

Как отсортировать подмассивы? Базовый случай быстрой сортировки
уже знает, как сортировать массивы из двух элементов (левый подмассив)
и пустые массивы (правый подмассив). Следовательно, если применить
алгоритм быстрой сортировки к двум подмассивам, а затем объединить
результаты, получится отсортированный массив!

quicksort([lS, 10]) + [33) + quicksort([])
> [ 10, 15, 33]

Этот метод работает при любом опорном элементе. Допустим, вместо 33
в качестве опорного был выбран элемент 15.

10 15 33

Оба подмассива состоят из одного элемента, а вы уже умеете сортировать
такие подмассивы. Получается, что вы умеете сортировать массивы из трех
элементов. Это делается так:

1 Выбрать опорный элемент.
2 Разделить массив на два подмассива: элементы, меньшие опорного,
и элементы, большие опорного.
3 Рекурсивно применить быструю сортировку к двум подмассивам.

Как насчет массива из четырех элементов?

33 10 15 7

Предположим, опорным снова выбирается элемен 33

Левый подмассив состоит из трех элементов. Вы уже знаете, как сортирует­
ся массив из трех элементов: нужно рекурсивно применить к нему быструю
сортировку.

[10 15 7] 33 []

[7] 10 [15]

Следовательно, вы можете отсортировать массив из четырех элементов.
А если вы можете отсортировать массив из четырех элементов, то вы так­
же можете отсортировать массив из пяти элементов. Почему? Допустим,
имеется массив из пяти элементов.

3 5 2 1 4

Вот как выглядят все варианты разделения этого массива в зависимости от
выбранного опорного элемента:

[] 1 [3 2 5 4]
[1] 2 [3 5 4]
[2 1] 3 [5 4]
[3 2 1] 4 [5]
[3 2 1 4] 5 []

Все эти подмассивы содержат от О до 4 элементов.
А вы уже знаете , как отсортировать массив, содержащий от О до 4 элементов.
с использованием быстрой сортировки! Таким образом, независимо от выбора опорного
элемента вы можете рекурсивно вызывать быструю сортировку для двух
подмассивов .

Например, предположим, что в качестве опорного выбирается элемент 3. Вы применяете быструю сортировку к подмассивам.

Подмассивы отсортированы, и теперь из них можно собрать отсортирован­
ный массив. Решение работает даже в том случае, если выбрать в качестве
опорного элемент 5:

Итак, решение работает независимо от выбора опорного элемента. Следо­
вательно, вы можете отсортировать массив из пяти элементов. По той же
логике вы можете отсортировать массив из шести элементов и т. д.

Доказательство по индукции

Оно состоит из двух частей базового случая и индукционного перехода

например нуно доказать что я могу подняться на верх стремянки
елси мои ноги стоят на ступеньке то я могу переставить их на следующую ступеньку - это индукционный переход
Таким образом если я стою на ступеньке 2 то могу подняться на ступеньку 3
что касается базового случая я стою на ступеньке 1
из этого следует что я могу подняться на самый верх стремянки каждый раз поднимаясь на одну ступеньку

Аналогичные рассуждения применимы к быстрой сортировке
Работоспособность алгоритма для базового случая массивов с размером 0 и 1 была продемонстрирована
В индукционном переходе я показал что если быстрая сортировка работает для саммива с 1 элементом
то она будет работать для массива из 2 элементов а если работает с 2 то будет и с 3 и так далее
Из этого следует что быстрая сортировка будет работать для всех массивов любого размера.

А вот как выглядит программный код быстрой сортировки:

def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]

        greater = [i for i in array[1:] if i > pivot]

        return quicksort(less) + [pivot] + quicksort(greater)

print quicksort([10, 5, 2, 3])

